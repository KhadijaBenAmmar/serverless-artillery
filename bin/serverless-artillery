#!/usr/bin/env node
const BbPromise = require('bluebird')
const fs = BbPromise.promisifyAll(require('fs'))
const os = require('os')
const path = require('path')
const packageJson = require('../package.json')
const slsArt = require('../lib/')

/**
 * Determine whether any of the given flags exists in the given argv (object representation)
 * @param flags The set flags to look for
 * @param argv The object containing the processed CLI arguments
 * @returns boolean Whether one of the given flags was a truthy value within the given argv object.
 */
const hasFlag = (flags, argv) => flags.some(
  (flag) => {
    const f = flag.split('-').join('') // remove '-' or '--'
    return f in argv && argv[f] // flag is defined in argv object (argv name is misleading) and has a truthy value
  } // eslint-disable-line comma-dangle
)

const bootstrap_error =
  `Error occured. Serverless-Artillery requires either Google Cloud Platform (GCP) or Amazon Web Service (AWS) to operate. 
   1) Learn how to setup GCP by following the instructions here: https://serverless.com/framework/docs/providers/google/guide/credentials/ 
   2) OR, Learn how to set up AWS provider credentials in our docs here: <http://bit.ly/aws-creds-setup>.)`
const cloudPlatformArgs = {
  gcpCredentialFileArg: "--gcp-creds-file",
  cloudPlatformArg: "--cloud-platform"
}

const yargs = require('yargs')
  .help()
  .version(packageJson.version)
  .options({
    D: {
      alias: 'debug',
      description: 'Execute the command in debug mode.  It will be chatty about what it is happening in the code.',
      requiresArg: false,
    },
    V: {
      alias: 'verbose',
      description: 'Execute the command in verbose mode.  It will be chatty about what it is attempting to accomplish.',
      requiresArg: false,
    },
    cloud_platform: {
      alias: "cloud-platform",
      description:
      'Chooses a platform of your choice between \'aws\' or \'gcp\'. If not provided, ' +
      'a default platform will be chosen based on the presence of ~/.gcloud or ~/.aws directory',
      requiresArg: false,
      type: 'string'
    },
    gcp_creds_file: {
      alias: "gcp-creds-file",
      description: 'Applicable for GCP platform only. This argument provides the file containing the ' +
      'service account credentials in JSON format. If not provided, the JSON file from ~/.gcloud/ is used. If that ' +
      'does not exist or in case multiple exists, please setup GCP credentials using ' +
      'https://serverless.com/framework/docs/providers/google/guide/credentials/',
      requiresArg: false,
      type: 'string'
    }
  })
  .global(['D', 'V', 'cloud_platform', 'gcp_creds_file'])
  .command('deploy', 'Deploy a default version of the function that will execute your Artillery scripts.'+
    os.EOL + os.EOL +
    'For AWS platform: See https://serverless.com/framework/docs/providers/aws/cli-reference/deploy/ as reference.' +
    os.EOL + os.EOL +
    'For GCP platform: use the option \'deploy help\' to view the respective options of deploy command', {})
  .command(
    'invoke',
    'Invoke your function with your Artillery script.  Will prefer a script given by `-d`, `--data`, `-p`, or ' +
    '`--path` over a `script.[yml|json]` file in the current directory over the default script.  Invocation mode ' +
    'will default to "performance" but adding the `-a` flag will run the script in "acceptance" mode.  ' +
    'See https://serverless.com/framework/docs/providers/aws/cli-reference/invoke/ for reference.',
    {
      a: {
        alias: 'acceptance',
        description: 'Execute the script in acceptance mode.  It will execute each flow once, reporting failures.',
        requiresArg: false,
      },
      m: {
        alias: 'monitoring',
        description: 'Execute the script in monitoring mode.  It will execute each flow a multiple of times, alerting ' +
          'if the number of errors exceeds the configured threshold.',
        requiresArg: false,
      },
      d: {
        alias: 'data',
        description: 'A stringified script to execute',
        requiresArg: true,
      },
      p: {
        alias: 'path',
        description: 'A path to the file containing the script to execute',
        requiresArg: true,
      },
      si: {
        alias: 'stdIn',
        description: 'Have serverless read the event to invoke the remote function with from the "standard in" stream',
        requiresArg: false,
      },
      jo: {
        alias: 'jsonOnly',
        description: 'Only write JSON to console.log to facilitate piping the invocation result into a tool such as jq',
        requiresArg: false,
      },
    },
    /**
     * Custom argument rejection logic, to deal with legacy, argument conflicts (between slsart and sls), and
     * unsupported flags.
     * @param argv The array of arguments that were provided to the CLI
     */
    (argv) => {
      const breakingFlags = [
        '-s', '--script',
      ]
      const reservedFlags = [
        '-t', '--type',
        '-f', '--function',
      ]
      const unsupportedFlags = [
        '--raw',
      ]
      // ##!! LEGACY MANAGEMENT BEGIN !!##
      // TODO Delete this block once transition is satisfactory (previously we accepted -s and --script to provide the
      // TODO artillery script.  This conflicts with the -s and --stage flags of the serverless framework.  As such,
      // TODO while we transition our users away from providing the script via -s/--script, we reject those flags and
      // TODO redirect them.
      // TODO Transition start date:
      if (hasFlag(breakingFlags, argv)) {
        console.error([
          os.EOL,
          `DDOS Off!${os.EOL}${os.EOL}`,
          `TL;DR: use -p/--path to supply a script, use --stage to supply a stage.${os.EOL}${os.EOL}`,
          `**BREAKING CHANGE**${os.EOL}`,
          'In order to facilitate the richer and more sustainable use of `serverless-artillery`, we have made a ',
          `'breaking change during this 0.x.x formation period.${os.EOL}`,
          'The `-s` flag you provided is no longer supported.  Instead, use the `-p` flag (still supplying the path ',
          'to your script.  The `-p` flag is the standard Serverless Framework flag for supplying a "path" to the ',
          `"event" file that is to be used to invoke the function.${os.EOL}`,
          'We apologize for not forseeing the consequence of our previous choice.  On the positive side, the feature ',
          'enabled by this change allows you to use any valid command line flag of the serverless framework with ',
          `\`slsart\` in order to facilitate your workflow, whatever is involved.${os.EOL}`,
          `Notable exceptions include: "${reservedFlags.join('", "')}" `,
          `flags which are reserved due to assumptions of \`serverless-artillery\`${os.EOL}`,
          `**BREAKING CHANGE**${os.EOL}${os.EOL}`,
          'NOTE: if you have intended to supply the "STAGE" of the service, please use the long form of that flag ' +
          `(\`--stage\`) to specify that setting.  This constraint will eventually be removed.${os.EOL}${os.EOL}`,
          `DDOS On!${os.EOL}${os.EOL}`,
        ].join(''))
        process.exit(1)
      }
      // ##!! LEGACY MANAGEMENT END   !!##
      if (hasFlag(reservedFlags, argv)) {
        console.error([
          os.EOL,
          `!ERROR!${os.EOL}`,
          'One of the `serverless` flags you provided is reserved for exclusive `serverless-artillery` use, ',
          `reserved flags include: "${
            Object.keys(reservedFlags).map(key => reservedFlags[key]).join('", "')
          }".${os.EOL}`,
          'Please see the "reserved flags" documentation in the README ',
          `(https://www.npmjs.com/package/serverless-artillery#reserved-flags).${os.EOL}`,
        ].join(''))
        process.exit(1)
      } else if (hasFlag(unsupportedFlags, argv)) {
        console.error([
          os.EOL,
          `!ERROR!${os.EOL}`,
          `One of the flags you provided is unsupported by \`serverless-artillery\`.  Unsupported flags include: "${
            Object.keys(unsupportedFlags).map(key => unsupportedFlags[key]).join('", "')}"${os.EOL}`,
          'Please see the "unsupported flags" documentation in the README ',
          `(https://www.npmjs.com/package/serverless-artillery#unsupported-flags).${os.EOL}`,
        ].join(''))
        process.exit(1)
      }
    } // eslint-disable-line comma-dangle
  )
  .command('kill', 'Stop a currently running load test and remove the function. Works only when the platform is AWS',
    {})
  .command('remove', 'Remove the function and the associated resources created for or by it.  See ' +
    'https://serverless.com/framework/docs/providers/aws/cli-reference/remove/ for reference.', {})
  .command(
    'script',
    'Create a local Artillery script so that you can customize it for your specific load requirements.  ' +
    'See https://artillery.io for documentation.',
    {
      e: {
        alias: 'endpoint',
        description: 'The endpoint to load with traffic.',
        requiresArg: true,
        type: 'string',
      },
      d: {
        alias: 'duration',
        description: 'The duration, in seconds, to load the given endpoint.',
        requiresArg: true,
        type: 'number',
      },
      r: {
        alias: 'rate',
        description: 'The rate, in requests per second, at which to load the given endpoint.',
        requiresArg: true,
        type: 'number',
      },
      t: {
        alias: 'rampTo',
        description: 'The rate to adjust towards away from the given rate, in requests per second at which to load ' +
          'the given endpoint.',
        requiresArg: true,
        type: 'number',
      },
      o: {
        alias: 'out',
        description: 'The file to output the generated script in to.',
        requiresArg: true,
        type: 'string',
      },
    } // eslint-disable-line comma-dangle
  )
  .command('configure', 'Create a local copy of the deployment assets for modification and deployment.  See ' +
    'https://docs.serverless.com for documentation.', {})
  .command(
    'monitor',
    'Modify or create a local copy of the deployment assets with declarations of a schedule upon which monitoring ' +
    'requests will occur as well as an SNS topic for sending alert notifications.',
    {
      p: {
        alias: 'path',
        description: 'The path of the script to schedule the function with.',
        requiresArg: true,
        type: 'string',
      },
      t: {
        alias: 'threshold',
        description: 'The minimum number of errors the system must observe prior to sending an alert notification',
        requiresArg: true,
        type: 'number',
      },
    } // eslint-disable-line comma-dangle
  )
  .demand(1)

const impl = {
  determineCloudPlatform: (options) => {
    if (options && options.cloud_platform) {
      if (options.verbose) {
        console.log(`cloud_platform argument already exists, value = ${options.cloud_platform}`)
      }
      if (options.cloud_platform === slsArt.cloudPlatform.aws || options.cloud_platform === slsArt.cloudPlatform.gcp)
      {
        return options.cloud_platform
      }
      else {
        throw new Error(
          `Invalid cloud_platform value: ${options.cloud_platform}. Valid values are ` +
          `\'${slsArt.cloudPlatform.gcp}\' or \'${slsArt.cloudPlatform.aws}\'`)
      }
    }
    const homeDir = os.homedir()
    const defaultGcloudDir = path.join(homeDir, ".gcloud")
    const defaultAwsDir = path.join(homeDir, ".aws")

    const gcloudExists = fs.existsSync(defaultGcloudDir) && fs.lstatSync(defaultGcloudDir).isDirectory()
    const awsExists = fs.existsSync(defaultAwsDir) && fs.lstatSync(defaultAwsDir).isDirectory()

    // if both exists, it is ambiguous, so an error
    if (gcloudExists && awsExists) {
      throw new Error(`Not able to determine the cloud platform since both the ~/.aws and ~/.gcloud directories exist` +
      `${bootstrap_error}`)
    }
    if (gcloudExists) {
      console.log('Determining gcp as cloud platform since ~/.gcloud exists')
      return slsArt.cloudPlatform.gcp
    }

    if (awsExists) {
      console.log('Determining aws as cloud platform since ~/.aws exists')
      return slsArt.cloudPlatform.aws
    }

    // none of the cloud platform directories exist, throw an error
    throw new Error(bootstrap_error)
  },
  findServiceAccountCredentialsFileForGCPPlatform: (cloudPlatform, options) => {
    if (cloudPlatform === slsArt.cloudPlatform.aws) {
      throw new Error(`No credentials file required for cloud platform = ${cloudPlatform}. Returning`)
    }
    if (options && options.gcp_creds_file) {
      throw new Error(`gcp_creds_file argument already exists. That one should be used instead`)
    }
    const homeDir = os.homedir()
    const defaultGcloudDir = path.join(homeDir, ".gcloud")
    const jsonFiles = []
    if (fs.existsSync(defaultGcloudDir)) {
      var stat = fs.lstatSync(defaultGcloudDir);
      if (stat.isDirectory()) {
        fs.readdirSync(defaultGcloudDir).forEach(fileName => {
          if (fileName.endsWith(".json")) {
            jsonFiles.push(fileName)
          }
        })
      }
      else {
        throw new Error(`.gcloud file exists but is not a directory in the home=${homeDir} directory. ${bootstrap_error}`)
      }
    }
    else {
      throw new Error(`.gcloud directory does not exist in home=${homeDir} directory. ${bootstrap_error}`)
    }

    if (jsonFiles.length === 1) {
      const jsonCredFile = path.join(defaultGcloudDir, jsonFiles[0])
      if (options.verbose) {
        console.log(`Returning the file ${jsonCredFile} as the credentials file for GCP platform`)
      }
      return jsonCredFile
    }
    else if (jsonFiles.length > 1) {
      throw new Error(`Multiple json files in ${defaultGcloudDir} = ${JSON.stringify(jsonFiles)}, ` +
      `please set the path to the file explicitly. ${bootstrap_error}`)
    }
    else {
      throw new Error(`No service account credential json file present in ` +
        `the default gcloud directory: ${defaultGcloudDir}. ${bootstrap_error}`)
    }
  },
}

const command = yargs.argv._[0]

if (yargs.argv.debug) {
  console.log(`options were:${os.EOL}${JSON.stringify(yargs.argv, null, 2)}`)
}

if (!(command in slsArt)) {
  yargs.showHelp()
  process.exit(1)
}

try {
  // determine the cloud platform to be used based on the arguments and environment
  const cloudPlatform = impl.determineCloudPlatform(yargs.argv)

  // set the credentials file argument
  if (cloudPlatform === slsArt.cloudPlatform.gcp && (yargs.argv && !yargs.argv.gcp_creds_file)) {
    var serviceAccountCredentialsFile = impl.findServiceAccountCredentialsFileForGCPPlatform(cloudPlatform, yargs.argv)
    if (!serviceAccountCredentialsFile) {
      throw new Error(`No service account credentials file present for the GCP cloud platform. ${bootstrap_error}`)
    }
    process.argv.push(`${cloudPlatformArgs.gcpCredentialFileArg}`)
    process.argv.push(serviceAccountCredentialsFile)
  }

  if (yargs.argv.debug) {
    console.log(
      `command that will be executed: slsArt[${command}](${cloudPlatform}, ${JSON.stringify(yargs.argv)})
      with process args: ${process.argv}`)
  }

  slsArt[command](cloudPlatform, yargs.argv)
    .catch((ex) => {
      if (yargs.argv.verbose || yargs.argv.debug) {
        console.error(ex.stack)
      }
      else {
        console.error(ex.message)
      }
      process.exit(1)
    })
} catch (err) {
  if (yargs.argv.verbose || yargs.argv.debug) {
    console.error(err)
  }
  else {
    console.error(err.message)
  }
  process.exit(1)
}



